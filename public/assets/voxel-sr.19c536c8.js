"use strict";(self.webpackChunkPixelPlanet=self.webpackChunkPixelPlanet||[]).push([[882],{5418:(e,t,n)=>{n.r(t),n.d(t,{default:()=>T});var o,i,a=n(9477);class s extends a.Mesh{constructor(){const e=s.SkyShader,t=new a.ShaderMaterial({name:"SkyShader",fragmentShader:e.fragmentShader,vertexShader:e.vertexShader,uniforms:a.UniformsUtils.clone(e.uniforms),side:a.BackSide,depthWrite:!1});super(new a.BoxGeometry(1,1,1),t)}}o=s,(i=function(e){var t=function(e,t){if("object"!=typeof e||null===e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var o=n.call(e,t);if("object"!=typeof o)return o;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(e)}(e,"string");return"symbol"==typeof t?t:String(t)}(i="isSky"))in o?Object.defineProperty(o,i,{value:true,enumerable:!0,configurable:!0,writable:!0}):o[i]=true,s.SkyShader={uniforms:{turbidity:{value:2},rayleigh:{value:1},mieCoefficient:{value:.005},mieDirectionalG:{value:.8},sunPosition:{value:new a.Vector3},up:{value:new a.Vector3(0,1,0)}},vertexShader:"\n  uniform vec3 sunPosition;\n  uniform float rayleigh;\n  uniform float turbidity;\n  uniform float mieCoefficient;\n  uniform vec3 up;\n\n  varying vec3 vWorldPosition;\n  varying vec3 vSunDirection;\n  varying float vSunfade;\n  varying vec3 vBetaR;\n  varying vec3 vBetaM;\n  varying float vSunE;\n\n  // constants for atmospheric scattering\n  const float e = 2.71828182845904523536028747135266249775724709369995957;\n  const float pi = 3.141592653589793238462643383279502884197169;\n\n  // wavelength of used primaries, according to preetham\n  const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );\n  // this pre-calculation replaces older TotalRayleigh(vec3 lambda) function:\n  // (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))\n  const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );\n\n  // mie stuff\n  // K coefficient for the primaries\n  const float v = 4.0;\n  const vec3 K = vec3( 0.686, 0.678, 0.666 );\n  // MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K\n  const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );\n\n  // earth shadow hack\n  // cutoffAngle = pi / 1.95;\n  const float cutoffAngle = 1.6110731556870734;\n  const float steepness = 1.5;\n  const float EE = 1000.0;\n\n  float sunIntensity( float zenithAngleCos ) {\n    zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );\n    return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );\n  }\n\n  vec3 totalMie( float T ) {\n    float c = ( 0.2 * T ) * 10E-18;\n    return 0.434 * c * MieConst;\n  }\n\n  void main() {\n\n    vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n    vWorldPosition = worldPosition.xyz;\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n    gl_Position.z = gl_Position.w; // set z to camera.far\n\n    vSunDirection = normalize( sunPosition );\n\n    vSunE = sunIntensity( dot( vSunDirection, up ) );\n\n    vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );\n\n    float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );\n\n    // extinction (absorption + out scattering)\n    // rayleigh coefficients\n    vBetaR = totalRayleigh * rayleighCoefficient;\n\n    // mie coefficients\n    vBetaM = totalMie( turbidity ) * mieCoefficient;\n\n  }",fragmentShader:"\n  varying vec3 vWorldPosition;\n  varying vec3 vSunDirection;\n  varying float vSunfade;\n  varying vec3 vBetaR;\n  varying vec3 vBetaM;\n  varying float vSunE;\n\n  uniform float mieDirectionalG;\n  uniform vec3 up;\n\n  const vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );\n\n  // constants for atmospheric scattering\n  const float pi = 3.141592653589793238462643383279502884197169;\n\n  const float n = 1.0003; // refractive index of air\n  const float N = 2.545E25; // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)\n\n  // optical length at zenith for molecules\n  const float rayleighZenithLength = 8.4E3;\n  const float mieZenithLength = 1.25E3;\n  // 66 arc seconds -> degrees, and the cosine of that\n  const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;\n\n  // 3.0 / ( 16.0 * pi )\n  const float THREE_OVER_SIXTEENPI = 0.05968310365946075;\n  // 1.0 / ( 4.0 * pi )\n  const float ONE_OVER_FOURPI = 0.07957747154594767;\n\n  float rayleighPhase( float cosTheta ) {\n    return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );\n  }\n\n  float hgPhase( float cosTheta, float g ) {\n    float g2 = pow( g, 2.0 );\n    float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );\n    return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );\n  }\n\n  void main() {\n\n    vec3 direction = normalize( vWorldPosition - cameraPos );\n\n    // optical length\n    // cutoff angle at 90 to avoid singularity in next formula.\n    float zenithAngle = acos( max( 0.0, dot( up, direction ) ) );\n    float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );\n    float sR = rayleighZenithLength * inverse;\n    float sM = mieZenithLength * inverse;\n\n    // combined extinction factor\n    vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );\n\n    // in scattering\n    float cosTheta = dot( direction, vSunDirection );\n\n    float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );\n    vec3 betaRTheta = vBetaR * rPhase;\n\n    float mPhase = hgPhase( cosTheta, mieDirectionalG );\n    vec3 betaMTheta = vBetaM * mPhase;\n\n    vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );\n    Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );\n\n    // nightsky\n    float theta = acos( direction.y ); // elevation --\x3e y-axis, [-pi/2, pi/2]\n    float phi = atan( direction.z, direction.x ); // azimuth --\x3e x-axis [-pi/2, pi/2]\n    vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );\n    vec3 L0 = vec3( 0.1 ) * Fex;\n\n    // composition + solar disc\n    float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );\n    L0 += ( vSunE * 19000.0 * Fex ) * sundisk;\n\n    vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );\n\n    vec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );\n\n    gl_FragColor = vec4( retColor, 1.0 );\n\n    #include <tonemapping_fragment>\n    #include <encodings_fragment>\n\n  }"};class r extends a.Mesh{constructor(e,t,n,o){let i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"xzy";n=n||new a.Color("white"),e=e||10,t=t||100,o=o||8e3;const s=i.substring(0,2);super(new a.PlaneBufferGeometry(2,2,1,1),new a.ShaderMaterial({side:a.DoubleSide,uniforms:{uSize1:{value:e},uSize2:{value:t},uColor:{value:n},uDistance:{value:o}},transparent:!0,vertexShader:`\n         varying vec3 worldPosition;\n         uniform float uDistance;\n         void main() {\n              vec3 pos = position.${i} * uDistance;\n              pos.${s} += cameraPosition.${s};\n\n              worldPosition = pos;\n\n              gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n         }\n         `,fragmentShader:`\n         varying vec3 worldPosition;\n\n         uniform float uSize1;\n         uniform float uSize2;\n         uniform vec3 uColor;\n         uniform float uDistance;\n\n          float getGrid(float size) {\n              vec2 r = worldPosition.${s} / size;\n\n              vec2 grid = abs(fract(r - 0.5) - 0.5) / fwidth(r);\n              float line = min(grid.x, grid.y);\n\n              return 1.0 - min(line, 1.0);\n          }\n\n         void main() {\n                float d = 1.0 - min(distance(cameraPosition.${s}, worldPosition.${s}) / uDistance, 1.0);\n\n                float g1 = getGrid(uSize1);\n                float g2 = getGrid(uSize2);\n\n\n                gl_FragColor = vec4(uColor.rgb, mix(g2, g1, g1) * pow(d, 3.0));\n                gl_FragColor.a = mix(0.5 * gl_FragColor.a, gl_FragColor.a, g2);\n\n                if ( gl_FragColor.a <= 0.0 ) discard;\n\n\n         }\n\n         `,extensions:{derivatives:!0}})),this.frustumCulled=!1}}var c=n(3861),l=n(6539);class h extends a.EventDispatcher{constructor(e,t,n){super(),void 0===t&&console.warn('THREE.VoxelPainterControls: The second parameter "domElement" is now mandatory.'),t===document&&console.error('THREE.VoxelPainterControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),this.object=e,this.domElement=t,this.store=n,this.enabled=!0,this.target=new a.Vector3,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=20,this.autoRotate=!1,this.autoRotateSpeed=2,this.mouseButtons={LEFT:a.MOUSE.ROTATE,MIDDLE:a.MOUSE.DOLLY,RIGHT:a.MOUSE.PAN},this.touches={ONE:a.TOUCH.ROTATE,TWO:a.TOUCH.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom;const o=this,i={type:"change"},s={type:"start"},r={type:"end"},h=-1;let u=h;const d=1e-6,m=new a.Spherical,f=new a.Spherical;this.moveLeft=!1,this.moveRight=!1,this.moveForward=!1,this.moveBackward=!1,this.moveUp=!1,this.moveDown=!1;let p=1;const v=new a.Vector3;let g=!1;const b=new a.Vector2,w=new a.Vector2,y=new a.Vector2,S=new a.Vector2,x=new a.Vector2,E=new a.Vector2,M=new a.Vector2,P=new a.Vector2,C=new a.Vector2;function k(){return.95**o.zoomSpeed}function D(e){f.theta-=e}function T(e){f.phi-=e}const j=new a.Vector3,R=(e,t)=>{j.setFromMatrixColumn(t,0),j.multiplyScalar(-e),v.add(j)},L=(e,t)=>{!0===o.screenSpacePanning?j.setFromMatrixColumn(t,1):(j.setFromMatrixColumn(t,0),j.crossVectors(o.object.up,j)),j.multiplyScalar(e),v.add(j)},A=(e,t)=>{const n=o.domElement;if(o.object.isPerspectiveCamera){const{position:i}=o.object;j.copy(i).sub(o.target);let a=j.length();a*=Math.tan(o.object.fov/2*Math.PI/180),R(2*e*a/n.clientHeight,o.object.matrix),L(2*t*a/n.clientHeight,o.object.matrix)}else o.object.isOrthographicCamera?(R(e*(o.object.right-o.object.left)/o.object.zoom/n.clientWidth,o.object.matrix),L(t*(o.object.top-o.object.bottom)/o.object.zoom/n.clientHeight,o.object.matrix)):(console.warn("WARNING: VoxelPainterControls.js encountered an unknown camera type - pan disabled."),o.enablePan=!1)};function O(e){o.object.isPerspectiveCamera?p/=e:o.object.isOrthographicCamera?(o.object.zoom=Math.max(o.minZoom,Math.min(o.maxZoom,o.object.zoom*e)),o.object.updateProjectionMatrix(),g=!0):(console.warn("WARNING: VoxelPainterControls.js encountered an unknown camera type - dolly/zoom disabled."),o.enableZoom=!1)}function z(e){o.object.isPerspectiveCamera?p*=e:o.object.isOrthographicCamera?(o.object.zoom=Math.max(o.minZoom,Math.min(o.maxZoom,o.object.zoom/e)),o.object.updateProjectionMatrix(),g=!0):(console.warn("WARNING: VoxelPainterControls.js encountered an unknown camera type - dolly/zoom disabled."),o.enableZoom=!1)}function V(e){b.set(e.clientX,e.clientY)}function B(e){S.set(e.clientX,e.clientY)}function F(e){if(1===e.touches.length)b.set(e.touches[0].pageX,e.touches[0].pageY);else{const t=.5*(e.touches[0].pageX+e.touches[1].pageX),n=.5*(e.touches[0].pageY+e.touches[1].pageY);b.set(t,n)}}function N(e){if(1===e.touches.length)S.set(e.touches[0].pageX,e.touches[0].pageY);else{const t=.5*(e.touches[0].pageX+e.touches[1].pageX),n=.5*(e.touches[0].pageY+e.touches[1].pageY);S.set(t,n)}}function U(e){const t=e.touches[0].pageX-e.touches[1].pageX,n=e.touches[0].pageY-e.touches[1].pageY,o=Math.sqrt(t*t+n*n);M.set(0,o)}function I(e){if(1===e.touches.length)w.set(e.touches[0].pageX,e.touches[0].pageY);else{const t=.5*(e.touches[0].pageX+e.touches[1].pageX),n=.5*(e.touches[0].pageY+e.touches[1].pageY);w.set(t,n)}y.subVectors(w,b).multiplyScalar(o.rotateSpeed);const t=o.domElement;D(2*Math.PI*y.x/t.clientHeight),T(2*Math.PI*y.y/t.clientHeight),b.copy(w)}function X(e){if(1===e.touches.length)x.set(e.touches[0].pageX,e.touches[0].pageY);else{const t=.5*(e.touches[0].pageX+e.touches[1].pageX),n=.5*(e.touches[0].pageY+e.touches[1].pageY);x.set(t,n)}E.subVectors(x,S).multiplyScalar(o.panSpeed),A(E.x,E.y),S.copy(x)}function Y(e){const t=e.touches[0].pageX-e.touches[1].pageX,n=e.touches[0].pageY-e.touches[1].pageY,i=Math.sqrt(t*t+n*n);P.set(0,i),C.set(0,(P.y/M.y)**o.zoomSpeed),O(C.y),M.copy(P)}function G(e){if(!1!==o.enabled&&"INPUT"!==e.target.nodeName&&"TEXTAREA"!==e.target.nodeName)switch(e.keyCode){case 38:case 87:o.moveForward=!0;break;case 37:case 65:o.moveLeft=!0;break;case 40:case 83:o.moveBackward=!0;break;case 39:case 68:o.moveRight=!0;break;case 69:o.moveUp=!0;break;case 67:o.moveDown=!0}}function Z(e){if(!1!==o.enabled&&"INPUT"!==e.target.nodeName&&"TEXTAREA"!==e.target.nodeName)switch(e.keyCode){case 38:case 87:o.moveForward=!1;break;case 37:case 65:o.moveLeft=!1;break;case 40:case 83:o.moveBackward=!1;break;case 39:case 68:o.moveRight=!1;break;case 69:o.moveUp=!1;break;case 67:o.moveDown=!1}}function H(e){if(!1!==o.enabled)switch(e.preventDefault(),u){case 0:!function(e){w.set(e.clientX,e.clientY),y.subVectors(w,b).multiplyScalar(o.rotateSpeed);const t=o.domElement;D(Math.PI*y.x/t.clientHeight),T(Math.PI*y.y/t.clientHeight),b.copy(w),o.update()}(e);break;case 1:!function(e){P.set(e.clientX,e.clientY),C.subVectors(P,M),C.y>0?O(k()):C.y<0&&z(k()),M.copy(P),o.update()}(e);break;case 2:!function(e){x.set(e.clientX,e.clientY),E.subVectors(x,S).multiplyScalar(o.panSpeed),A(E.x,E.y),S.copy(x),o.update()}(e)}}function W(e){!1!==o.enabled&&(document.removeEventListener("mousemove",H,!1),document.removeEventListener("mouseup",W,!1),o.dispatchEvent(r),u=h)}function _(e){!1===o.enabled||!1===o.enableZoom||u!==h&&0!==u||(e.preventDefault(),e.stopPropagation(),o.dispatchEvent(s),function(e){e.deltaY<0?z(k()):e.deltaY>0&&O(k()),o.update()}(e),o.dispatchEvent(r))}function $(e){if(!1!==o.enabled){switch(e.preventDefault(),e.touches.length){case 1:switch(o.touches.ONE){case a.TOUCH.ROTATE:if(!1===o.enableRotate)return;F(e),u=3;break;case a.TOUCH.PAN:if(!1===o.enablePan)return;N(e),u=4;break;default:u=h}break;case 2:switch(o.touches.TWO){case a.TOUCH.DOLLY_PAN:if(!1===o.enableZoom&&!1===o.enablePan)return;!function(e){o.enableZoom&&U(e),o.enablePan&&N(e)}(e),u=5;break;case a.TOUCH.DOLLY_ROTATE:if(!1===o.enableZoom&&!1===o.enableRotate)return;!function(e){o.enableZoom&&U(e),o.enableRotate&&F(e)}(e),u=6;break;default:u=h}break;default:u=h}u!==h&&o.dispatchEvent(s)}}function K(e){if(!1!==o.enabled)switch(e.preventDefault(),e.stopPropagation(),u){case 3:if(!1===o.enableRotate)return;I(e),o.update();break;case 4:if(!1===o.enablePan)return;X(e),o.update();break;case 5:if(!1===o.enableZoom&&!1===o.enablePan)return;!function(e){o.enableZoom&&Y(e),o.enablePan&&X(e)}(e),o.update();break;case 6:if(!1===o.enableZoom&&!1===o.enableRotate)return;!function(e){o.enableZoom&&Y(e),o.enableRotate&&I(e)}(e),o.update();break;default:u=h}}function q(e){!1!==o.enabled&&(o.dispatchEvent(r),u=h)}function Q(e){!1!==o.enabled&&e.preventDefault()}function J(e){if(!1===o.enabled)return;let t;switch(e.preventDefault(),o.domElement.focus?o.domElement.focus():window.focus(),e.button){case 0:t=o.mouseButtons.LEFT;break;case 1:t=o.mouseButtons.MIDDLE;break;case 2:t=o.mouseButtons.RIGHT;break;default:t=-1}switch(t){case a.MOUSE.DOLLY:!function(e){M.set(e.clientX,e.clientY)}(e),u=1;break;case a.MOUSE.ROTATE:e.ctrlKey||e.metaKey?(B(e),u=2):(V(e),u=0);break;case a.MOUSE.PAN:e.ctrlKey||e.metaKey?(V(e),u=0):(B(e),u=2);break;default:u=h}u!==h&&(document.addEventListener("mousemove",H,!1),document.addEventListener("mouseup",W,!1),o.dispatchEvent(s))}o.domElement.addEventListener("contextmenu",Q,!1),o.domElement.addEventListener("mousedown",J,!1),o.domElement.addEventListener("wheel",_,!1),document.addEventListener("keydown",G,!1),document.addEventListener("keyup",Z,!1),o.domElement.addEventListener("touchstart",$,!1),o.domElement.addEventListener("touchend",q,!1),o.domElement.addEventListener("touchmove",K,!1),-1===o.domElement.tabIndex&&(o.domElement.tabIndex=0),this.getPolarAngle=()=>m.phi,this.getAzimuthalAngle=()=>m.theta,this.saveState=()=>{o.target0.copy(o.target),o.position0.copy(o.object.position),o.zoom0=o.object.zoom},this.reset=()=>{o.target.copy(o.target0),o.object.position.copy(o.position0),o.object.zoom=o.zoom0,o.object.updateProjectionMatrix(),o.dispatchEvent(i),o.update(),u=h},this.setView=e=>{3===e.length&&o.target.set(...e)},this.update=(()=>{const t=new a.Vector3,n=(new a.Quaternion).setFromUnitVectors(e.up,new a.Vector3(0,1,0)),s=n.clone().invert(),r=new a.Vector3,b=new a.Quaternion;let w=Date.now();const y=new a.Vector3,S=new a.Vector3;let x=Date.now();const E=new a.Vector3;return function(){const e=Date.now(),a=(e-x)/1e3;S.x-=40*S.x*a,S.y-=40*S.y*a,S.z-=40*S.z*a;const M=S.length();(M<1||M>10)&&S.set(0,0,0);const{moveRight:P,moveLeft:C,moveUp:k,moveDown:T,moveForward:j,moveBackward:R}=o;y.x=Number(P)-Number(C),y.y=Number(k)-Number(T),y.z=Number(j)-Number(R),y.normalize(),(C||P)&&(S.x-=1e3*y.x*a),(k||T)&&(S.y-=1e3*y.y*a),(j||R)&&(S.z-=500*y.z*a),E.setFromMatrixColumn(o.object.matrix,0),E.crossVectors(o.object.up,E),E.multiplyScalar(-S.z*a),E.y+=-S.y*a,v.add(E),E.setFromMatrixColumn(o.object.matrix,0),E.multiplyScalar(-S.x*a),v.add(E),x=e;const{position:L}=o.object;t.copy(L).sub(o.target),t.applyQuaternion(n),m.setFromVector3(t),o.autoRotate&&u===h&&D(2*Math.PI/60/60*o.autoRotateSpeed),o.enableDamping?(m.theta+=f.theta*o.dampingFactor,m.phi+=f.phi*o.dampingFactor):(m.theta+=f.theta,m.phi+=f.phi),m.theta=Math.max(o.minAzimuthAngle,Math.min(o.maxAzimuthAngle,m.theta)),m.phi=Math.max(o.minPolarAngle,Math.min(o.maxPolarAngle,m.phi)),m.makeSafe(),m.radius*=p,m.radius=Math.max(o.minDistance,Math.min(o.maxDistance,m.radius)),v.length()>1e3&&v.set(0,0,0),!0===o.enableDamping?o.target.addScaledVector(v,o.dampingFactor):o.target.add(v);const A=o.store.getState(),{canvasSize:O}=A.canvas,z=O/2;if(o.target.clamp({x:-z,y:10,z:-z},{x:z,y:l.Tj,z}),t.setFromSpherical(m),t.applyQuaternion(s),L.copy(o.target).add(t),o.object.lookAt(o.target),!0===o.enableDamping){if(f.theta*=1-o.dampingFactor,f.phi*=1-o.dampingFactor,v.multiplyScalar(1-o.dampingFactor),v.length()<.2&&0!==v.length())v.set(0,0,0),o.store.dispatch((0,c.w5)(o.target.toArray())),o.store.dispatch((0,c.a6)());else if(0!==v.length()){const e=Date.now();e>w+500&&(w=e,o.store.dispatch((0,c.w5)(o.target.toArray())),o.store.dispatch((0,c.a6)()))}}else f.set(0,0,0),v.set(0,0,0);return p=1,!!(g||r.distanceToSquared(o.object.position)>d||8*(1-b.dot(o.object.quaternion))>d)&&(o.dispatchEvent(i),r.copy(o.object.position),b.copy(o.object.quaternion),g=!1,!0)}})(),this.dispose=()=>{o.domElement.removeEventListener("contextmenu",Q,!1),o.domElement.removeEventListener("mousedown",J,!1),o.domElement.removeEventListener("wheel",_,!1),o.domElement.removeEventListener("touchstart",$,!1),o.domElement.removeEventListener("touchend",q,!1),o.domElement.removeEventListener("touchmove",K,!1),document.removeEventListener("mousemove",H,!1),document.removeEventListener("mouseup",W,!1),document.removeEventListener("keydown",G,!1),document.removeEventListener("keyup",Z,!1)},this.update()}}const u=h;var d=n(1430),m=n(3968),f=n(9483);function p(e,t,n){return(t=function(e){var t=function(e,t){if("object"!=typeof e||null===e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var o=n.call(e,t);if("object"!=typeof o)return o;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(e)}(e,"string");return"symbol"==typeof t?t:String(t)}(t))in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}const v=[[-1,0,0],[1,0,0],[0,-1,0],[0,1,0],[0,0,-1],[0,0,1]],g=[[[0,1,0],[0,0,0],[0,1,1],[0,0,1]],[[1,1,1],[1,0,1],[1,1,0],[1,0,0]],[[1,0,1],[0,0,1],[1,0,0],[0,0,0]],[[0,1,1],[1,1,1],[0,1,0],[1,1,0]],[[1,0,0],[0,0,0],[1,1,0],[0,1,0]],[[0,0,1],[1,0,1],[0,1,1],[1,1,1]]],b=new a.MeshLambertMaterial({vertexColors:!0});class w extends f.Z{constructor(e,t,n,o){super(0,n,o),p(this,"key",void 0),p(this,"ready",!1),p(this,"palette",void 0),p(this,"buffer",void 0),p(this,"mesh",null),p(this,"faceCnt",void 0),p(this,"lastPixel",void 0),p(this,"heightMap",void 0),this.recUpdates=!0,this.key=t,this.palette=e}destructor(){this.mesh&&this.mesh.geometry.dispose()}getVoxel(e,t,n){const{buffer:o}=this;if(!o)return 0;if(e<0||e>=l.fS||t>=l.Tj||n<0||n>=l.fS)return 0;if(t<0)return 1;const i=w.getOffsetOfVoxel(e,t,n);return this.buffer[i]}getVoxelByOffset(e){const{buffer:t}=this;return t?t[e]:0}static calculateMetaData(e){const t=l.fS**2,n=new Uint8Array(t);let o=0,i=0,a=0;for(let s=l.fS-1;s>=0;--s)for(let r=l.fS-1;r>=0;--r){let c=0;const h=r+s*l.fS;let u=h;for(let n=0;n<l.Tj;++n)0!==e[u]&&(c=n,0!==r&&0!==e[u-1]||(a+=1),r!==l.fS-1&&0!==e[u+1]||(a+=1),0!==s&&0!==e[u-l.fS]||(a+=1),s!==l.fS-1&&0!==e[u+l.fS]||(a+=1),0!==n&&0===e[u-l.fS**2]&&(a+=1),n!==l.Tj-1&&0!==e[u+l.fS**2]||(a+=1)),u+=t;n[h]=c,c>o&&(o=c,i=w.getOffsetOfVoxel(r,c,s))}return[a,i,n]}static getOffsetOfVoxel(e,t,n){return e+n*l.fS+t*l.fS*l.fS}static getXZOfVoxel(e){const t=e%(l.fS*l.fS),n=(e-t)/(l.fS*l.fS),o=t%l.fS;return[o,n,(t-o)/l.fS]}setVoxelByOffset(e,t){e>this.lastPixel&&(this.lastPixel=e);const n=l.fS**2,o=e%n,i=(e-o)/n;i>this.heightMap[o]&&(this.heightMap[o]=i),this.buffer[e]=t,this.faceCnt+=6,this.renderChunk()}setVoxel(e,t,n,o){const i=w.getOffsetOfVoxel(e,t,n);this.setVoxelByOffset(i,o)}async fromBuffer(e){let t=e;const n=l.fS**2*l.Tj;t.byteLength<n&&(console.log(`Padding chunk ${this.key} with ${n-t.byteLength} voxels to full length`),t=new Uint8Array(n),t.set(e)),this.buffer=t;const[o,i,a]=w.calculateMetaData(t);this.faceCnt=o,this.lastPixel=i,this.heightMap=a,this.renderChunk(),this.ready=!0}empty(){const e=new Uint8Array(l.fS*l.fS*l.Tj),t=new Uint8Array(l.fS*l.fS);this.buffer=e,this.heightMap=t,this.faceCnt=0,this.lastPixel=0,this.renderChunk(),this.ready=!0}calculateGeometryData(){const e=l.fS**2;let t,n=0;const{faceCnt:o}=this,i=new Float32Array(4*o*3),a=new Float32Array(4*o*3),s=new Uint8Array(4*o*3),r=new Uint32Array(6*o),{rgb:c}=this.palette;for(let o=0;o<l.fS;++o)for(let h=0;h<l.fS;++h){const u=h+o*l.fS,d=this.heightMap[u];let m=u;for(let l=0;l<=d;++l){if(t=63&this.buffer[m],0!==t){t*=3;for(let e=0;e<6;++e){const u=v[e],d=g[e];if(0===this.getVoxel(h+u[0],l+u[1],o+u[2])){let e=4*n*3;for(let n=0;n<4;++n){const r=d[n];i[e]=r[0]+h,a[e]=u[0],s[e++]=c[t],i[e]=r[1]+l,a[e]=u[1],s[e++]=c[t+1],i[e]=r[2]+o,a[e]=u[2],s[e++]=c[t+2]}const m=4*n;e=6*n,r[e++]=m,r[e++]=m+1,r[e++]=m+2,r[e++]=m+2,r[e++]=m+1,r[e]=m+3,n+=1}}}m+=e}}return this.faceCnt=n,[i,a,s,r]}renderChunk(){const[e,t,n,o]=this.calculateGeometryData(),i=this.mesh?this.mesh.geometry:new a.BufferGeometry;i.setAttribute("position",new a.BufferAttribute(e,3)),i.setAttribute("normal",new a.BufferAttribute(t,3)),i.setAttribute("color",new a.BufferAttribute(n,3,!0)),i.setIndex(new a.BufferAttribute(o,1)),i.computeBoundingSphere(),i.setDrawRange(0,6*this.faceCnt),this.mesh||(this.mesh=new a.Mesh(i,b),this.mesh.name=this.key)}}const y=w;var S=n(9665),x=n(980);class E extends m.Z{constructor(e,t,n,o){super(e,t),function(e,t,n){(t=function(e){var t=function(e,t){if("object"!=typeof e||null===e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var o=n.call(e,t);if("object"!=typeof o)return o;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(e)}(e,"string");return"symbol"==typeof t?t:String(t)}(t))in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n}(this,"palette",void 0),this.palette=n,this.canvasSize=o}getVoxel(e,t,n){const{canvasSize:o}=this,[i,a]=(0,S.sG)(o,e,t,n),s=(0,S.NK)(o,e,t,n),r=`${i}:${a}`,c=this.cget(r);return c?c.getVoxelByOffset(s):0}getVoxelUpdate(e,t,n,o){const i=`${e}:${t}`,a=this.cget(i);a&&a.setVoxelByOffset(n,o)}getChunk(e,t,n){const o=`${e}:${t}`;let i=this.cget(o);return i?i.ready?(i.touch(),i.mesh):null:(n&&(i=new y(this.palette,o,e,t),this.cset(o,i),this.fetchChunk(e,t,i)),null)}async fetchChunk(e,t,n){this.bcReqChunk(n);try{const o=`${x.Fx}/chunks/${this.canvasId}/${e}/${t}.bmp`,i=await fetch(o);if(!i.ok)throw new Error("Network response was not ok.");{const e=await i.arrayBuffer();if(!e.byteLength)throw new Error("Chunk response was invalid");{const t=new Uint8Array(e);n.fromBuffer(t)}this.bcRecChunk(n)}}catch(e){n.empty(),this.bcReqChunkFail(n,e)}}}const M=E;var P=n(8821);function C(e,t,n){return(t=function(e){var t=function(e,t){if("object"!=typeof e||null===e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var o=n.call(e,t);if("object"!=typeof o)return o;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(e)}(e,"string");return"symbol"==typeof t?t:String(t)}(t))in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}const k=150;class D extends d.Z{constructor(e){super(e),C(this,"is3D",!0),C(this,"scene",void 0),C(this,"camera",void 0),C(this,"rollOverMesh",void 0),C(this,"objects",void 0),C(this,"loadedChunks",void 0),C(this,"plane",void 0),C(this,"oobGeometry",void 0),C(this,"oobMaterial",void 0),C(this,"controls",void 0),C(this,"threeRenderer",void 0),C(this,"mouse",void 0),C(this,"mouseMoveStart",void 0),C(this,"raycaster",void 0),C(this,"pressTime",void 0),C(this,"pressCdTime",void 0),C(this,"multitap",void 0),C(this,"forceNextRender",!1);const t=e.getState();this.objects=[];const n=new a.PerspectiveCamera(45,window.innerWidth/window.innerHeight,1,400);n.position.set(10,16,26),n.lookAt(0,0,0),this.camera=n;const o=new a.Scene;this.scene=o;const i=new a.AmbientLight(2236962);o.add(i);const c=new a.DirectionalLight(16777215,1);c.position.set(80,80,75);const h=new a.DirectionalLight(16777215,.4);h.position.set(-80,80,-75),o.add(c),o.add(h);const d=new s;d.scale.setScalar(45e4),o.add(d),o.fog=new a.FogExp2(16777215,.003);const{uniforms:m}=d.material;m.turbidity.value=10,m.rayleigh.value=2,m.mieCoefficient.value=.005,m.mieDirectionalG.value=.8,m.sunPosition.value.set(4e5,4e5,4e5);const f=new a.BoxBufferGeometry(1,1,1),p=new a.MeshBasicMaterial({color:16711680,opacity:.5,transparent:!0});this.rollOverMesh=new a.Mesh(f,p),o.add(this.rollOverMesh);const v=new r(1,10);o.add(v),this.raycaster=new a.Raycaster,this.mouse=new a.Vector2,this.multitap=0;const g=new a.PlaneBufferGeometry(1024,1024);g.rotateX(-Math.PI/2);const b=new a.Mesh(g,new a.MeshLambertMaterial({color:13296639}));o.add(b),this.plane=b,this.objects.push(b),this.plane.position.y=-.1;const w=new a.PlaneBufferGeometry(l.fS,l.fS);w.rotateX(-Math.PI/2),w.translate(l.fS/2,.2,l.fS/2);const y=new a.MeshLambertMaterial({color:"#C4C4C4"});this.oobGeometry=w,this.oobMaterial=y;const S=new a.WebGLRenderer({preserveDrawingBuffer:!0});S.setPixelRatio(window.devicePixelRatio),S.setSize(window.innerWidth,window.innerHeight);const{domElement:x}=S;x.className="viewport",document.body.appendChild(x),this.threeRenderer=S;const E=new u(n,x,e);E.enableDamping=!0,E.dampingFactor=.1,E.maxPolarAngle=Math.PI/2,E.minDistance=10,E.maxDistance=100,this.controls=E,this.onDocumentMouseMove=this.onDocumentMouseMove.bind(this),this.onDocumentTouchMove=this.onDocumentTouchMove.bind(this),this.onDocumentMouseDownOrTouchStart=this.onDocumentMouseDownOrTouchStart.bind(this),this.onDocumentMouseUp=this.onDocumentMouseUp.bind(this),this.onWindowResize=this.onWindowResize.bind(this),this.onDocumentTouchEnd=this.onDocumentTouchEnd.bind(this),this.multiTapEnd=this.multiTapEnd.bind(this),x.addEventListener("mousemove",this.onDocumentMouseMove,!1),x.addEventListener("touchmove",this.onDocumentTouchMove,!1),x.addEventListener("mousedown",this.onDocumentMouseDownOrTouchStart,!1),x.addEventListener("touchstart",this.onDocumentMouseDownOrTouchStart,!1),x.addEventListener("touchend",this.onDocumentTouchEnd,!1),x.addEventListener("mouseup",this.onDocumentMouseUp,!1),window.addEventListener("resize",this.onWindowResize,!1),this.updateCanvasData(t)}destructor(){window.removeEventListener("resize",this.onWindowResize,!1),this.threeRenderer.dispose(),this.controls.dispose();const{domElement:e}=this.threeRenderer;this.threeRenderer=null,e.remove(),super.destructor()}updateView(){this.forceNextRender=!0}getViewport(){return this.threeRenderer.domElement}updateCanvasData(e){const{canvasId:t,view:n}=e.canvas;if(t!==this.canvasId&&(this.canvasId=t,null!==t)){this.chunkLoader&&this.loadedChunks&&(this.loadedChunks.forEach((e=>{this.scene.remove(e),this.objects=[this.plane]})),this.chunkLoader.destructor()),this.loadedChunks=new Map;const{palette:n,canvasSize:o}=e.canvas;this.chunkLoader=new M(this.store,t,n,o)}this.controls.setView(n),this.forceNextRender=!0}updateScale(){return null}renderPixel(e,t,n,o){const{chunkLoader:i}=this;i&&i.getVoxelUpdate(e,t,n,o)}isChunkInView(e,t,n){const o=`${t}:${n}`;return!!this.loadedChunks.has(o)}reloadChunks(){if(!this.chunkLoader)return;const e=this.store.getState(),{canvasSize:t,view:n}=e.canvas,o=n[0],i=n[2]||0,{scene:s,loadedChunks:r,chunkLoader:c}=this,[h,u]=(0,S.sG)(t,o-k,0,i-k),[d,m]=(0,S.sG)(t,o+k,0,i+k),f=t/l.fS,p=[];for(let e=u;e<=m;++e)for(let n=h;n<=d;++n){const o=`${n}:${e}`;if(p.push(o),!r.has(o)){let i=null;i=n<0||e<0||n>=f||e>=f?new a.Mesh(this.oobGeometry,this.oobMaterial):c.getChunk(n,e,!0),i&&(r.set(o,i),i.position.fromArray([n*l.fS-t/2,0,e*l.fS-t/2]),s.add(i))}}const v=[this.plane];r.forEach(((e,t)=>{p.includes(t)?v.push(e):(s.remove(e),r.delete(t))})),this.plane.position.x=o,this.plane.position.z=i,this.objects=v}render(){this.threeRenderer&&(this.controls.update(),this.forceNextRender&&(this.reloadChunks(),this.forceNextRender=!1),this.threeRenderer.render(this.scene,this.camera))}onWindowResize(){this.camera.aspect=window.innerWidth/window.innerHeight,this.camera.updateProjectionMatrix(),this.threeRenderer.setSize(window.innerWidth,window.innerHeight)}onDocumentMouseMove(e){e.preventDefault();const{clientX:t,clientY:n}=e,{innerWidth:o,innerHeight:i}=window,{camera:a,objects:s,raycaster:r,mouse:l,rollOverMesh:h,store:u}=this,{fetchingPixel:d}=u.getState().fetching;l.set(t/o*2-1,-n/i*2+1),r.setFromCamera(l,a);const m=r.intersectObjects(s);if(m.length>0){const e=m[0],t=e.point.clone().add(e.face.normal.multiplyScalar(.5)).floor().addScalar(.5);if(d||t.clone().sub(a.position).length()>120)h.position.y=-10;else{h.position.copy(t);const e=t.toArray().map((e=>Math.floor(e)));this.store.dispatch((0,c.GZ)(e))}}}onDocumentMouseDownOrTouchStart(){this.pressTime=Date.now();const e=this.store.getState();this.mouseMoveStart=e.canvas.hover}onDocumentTouchMove(){const{camera:e,objects:t,raycaster:n,mouse:o,rollOverMesh:i,store:a}=this,{fetchingPixel:s}=a.getState().fetching;o.set(0,0),n.setFromCamera(o,e);const r=n.intersectObjects(t);if(r.length>0){const t=r[0],n=t.point.clone().add(t.face.normal.multiplyScalar(.5)).floor().addScalar(.5);if(s||n.clone().sub(e.position).length()>50)i.position.y=-10;else{i.position.copy(n);const e=n.toArray().map((e=>Math.floor(e)));this.store.dispatch((0,c.GZ)(e))}}}placeVoxel(e,t,n){let o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const{store:i}=this,a=i.getState(),{canvasSize:s,selectedColor:r}=a.canvas,c=null===o?r:o,l=0===c?this.chunkLoader.getVoxel(e,t,n):0,[h,u]=(0,S.sG)(s,e,t,n),d=(0,S.NK)(s,e,t,n);P.Z.tryPlacePixel(h,u,d,c,l)}multiTapEnd(){const{store:e,mouseMoveStart:t,multitap:n}=this;this.multitap=0;const o=e.getState(),[i,a,s]=t,[r,c,l]=o.canvas.hover;if(i===r&&a===c&&s===l)switch(n){case 1:if(this.rollOverMesh.position.y<0)return;this.placeVoxel(i,a,s);break;case 2:{const{mouse:e,raycaster:t,camera:n,objects:o}=this;e.set(0,0),t.setFromCamera(e,n);const i=t.intersectObjects(o);if(i.length>0){const e=i[0],t=e.point.clone().add(e.face.normal.multiplyScalar(-.5)).floor().addScalar(.5).floor();if(t.y<0)return;if(t.clone().sub(n.position).length()<=50){const[e,n,o]=t.toArray();this.placeVoxel(e,n,o,0)}}break}}}onDocumentTouchEnd(e){e.preventDefault(),Date.now()-this.pressTime>600?this.multitap=0:(0===this.multitap&&setTimeout(this.multiTapEnd,500),this.multitap+=1)}onDocumentMouseUp(e){const t=Date.now();if(t-this.pressCdTime<200)return;if(t-this.pressTime>500)return void(this.pressCdTime=t);const n=this.store.getState(),{isOnMobile:o}=n.user,{fetchingPixel:i}=n.fetching;if(i||o)return;const[a,s,r]=this.mouseMoveStart,[l,h,u]=n.canvas.hover;if(a!==l||s!==h||r!==u)return;e.preventDefault();const{clientX:d,clientY:m,button:f}=e,{innerWidth:p,innerHeight:v}=window,{camera:g,objects:b,raycaster:w,mouse:y,store:S}=this;y.set(d/p*2-1,-m/v*2+1),w.setFromCamera(y,g);const x=w.intersectObjects(b);if(x.length>0){const e=x[0];if(0===f){const t=e.point.clone().add(e.face.normal.multiplyScalar(.5)).floor().addScalar(.5).floor();if(t.clone().sub(g.position).length()<120){const[e,n,o]=t.toArray();this.placeVoxel(e,n,o)}}else if(1===f){const t=e.point.clone().add(e.face.normal.multiplyScalar(-.5)).floor().addScalar(.5).floor();if(t.y<0)return;if(t.clone().sub(g.position).length()<120){const e=t.toArray();if(this.chunkLoader){const t=this.chunkLoader.getVoxel(...e);t&&S.dispatch((0,c.Oh)(t))}}}else if(2===f){const t=e.point.clone().add(e.face.normal.multiplyScalar(-.5)).floor().addScalar(.5).floor();if(t.y<0)return;if(t.clone().sub(g.position).length()<120){const[e,n,o]=t.toArray();this.placeVoxel(e,n,o,0)}}}}}const T=D}}]);